# Azure DevOps Pipeline for Pixelated Empathy
#
trigger:
  branches:
    include:
      - master
      - develop
  paths:
    include:
      - src/**
      - deploy/azure/**
      - Dockerfile.azure
      - azure-pipelines.yml
      - .azure-pipelines/**
      - package.json
      - pnpm-lock.yaml

pr:
  branches:
    include:
      - master
      - develop

variables:
  # Build Configuration
  buildConfiguration: Release
  nodeVersion: 22.x

  # Azure Configuration
  azureSubscription: pixelated-service-connection
  resourceGroupName: pixelated-rg
  appServiceName: pixelated-app
  containerRegistry: pixelatedcr.azurecr.io
  containerRegistryServiceConnection: 'Azure Container Registry'
  imageName: pixelated-web

  # Azure Resource Configuration
  azureSubscriptionId: $(AZURE_SUBSCRIPTION_ID)
  azureStorageContainerName: $(AZURE_STORAGE_CONTAINER_NAME)
  publicSiteUrl: $(PUBLIC_SITE_URL)

  # Build specific variables
  buildId: $(Build.BuildId)
  buildNumber: $(Build.BuildNumber)

  # Environment Variables
  ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/master') }}:
    environment: production
    deploymentSlot: production
    azureLocation: eastus
  ${{ else }}:
    environment: staging
    deploymentSlot: staging
    azureLocation: eastus

stages:
  # Build Stage
  - stage: Build
    displayName: Build Application
    jobs:
      - job: BuildJob
        displayName: Build and Test
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - task: NodeTool@0
            displayName: Install Node.js
            inputs:
              versionSpec: $(nodeVersion)

          - task: Cache@2
            displayName: Cache pnpm dependencies
            inputs:
              key: pnpm | "$(Agent.OS)" | pnpm-lock.yaml
              restoreKeys: |
                pnpm | "$(Agent.OS)"
              path: $(Pipeline.Workspace)/.pnpm-store

          - script: |
              npm install -g pnpm
              pnpm config set store-dir $(Pipeline.Workspace)/.pnpm-store
              pnpm install --no-frozen-lockfile
            displayName: Install dependencies

          - script: |
              pnpm run lint:ci
            displayName: Run linting
            continueOnError: true
            condition: succeededOrFailed()
            env:
              PUBLIC_SITE_URL: $(PUBLIC_SITE_URL)
              AZURE_STORAGE_CONTAINER_NAME: $(AZURE_STORAGE_CONTAINER_NAME)
              AZURE_RESOURCE_GROUP: $(resourceGroupName)
              AZURE_LOCATION: $(azureLocation)
              AZURE_SUBSCRIPTION_ID: $(azureSubscriptionId)
              AZURE_STATIC_WEB_APP_NAME: $(AZURE_STATIC_WEB_APP_NAME)
              AZURE_APP_SERVICE_NAME: $(appServiceName)
              AZURE_APP_SERVICE_PLAN: $(AZURE_APP_SERVICE_PLAN)
              AZURE_FUNCTIONS_NAME: $(AZURE_FUNCTIONS_NAME)
              AZURE_FUNCTIONS_STORAGE: $(AZURE_FUNCTIONS_STORAGE)

          - script: |
              pnpm run type-check || echo "Type checking completed with warnings/errors but continuing build"
            displayName: Run type checking
            continueOnError: true
            condition: succeededOrFailed()
            env:
              PUBLIC_SITE_URL: $(PUBLIC_SITE_URL)
              AZURE_STORAGE_CONTAINER_NAME: $(AZURE_STORAGE_CONTAINER_NAME)
              AZURE_RESOURCE_GROUP: $(resourceGroupName)
              AZURE_LOCATION: $(azureLocation)
              AZURE_SUBSCRIPTION_ID: $(azureSubscriptionId)
              AZURE_STATIC_WEB_APP_NAME: $(AZURE_STATIC_WEB_APP_NAME)
              AZURE_APP_SERVICE_NAME: $(appServiceName)
              AZURE_APP_SERVICE_PLAN: $(AZURE_APP_SERVICE_PLAN)
              AZURE_FUNCTIONS_NAME: $(AZURE_FUNCTIONS_NAME)
              AZURE_FUNCTIONS_STORAGE: $(AZURE_FUNCTIONS_STORAGE)

          - script: |
              # Set memory limits and test configuration for CI
              export NODE_OPTIONS="--max_old_space_size=4096 --expose-gc"
              export TEST_TIMEOUT="30000"
              export VITEST_MIN_THREADS="1"
              export VITEST_MAX_THREADS="2"
              export CI="true"
              
              # Use Upstash Redis from environment variables
              export REDIS_URL="${REDIS_URL:-rediss://default:AS3JAAIjcDFlOGQ0YWIzOGYxYmU0MDU3YTlmZGFmYjI1NjQ1OGUwZHAxMA@neutral-ray-11721.upstash.io:6379}"
              export UPSTASH_REDIS_REST_URL="${UPSTASH_REDIS_REST_URL:-https://neutral-ray-11721.upstash.io}"
              export UPSTASH_REDIS_REST_TOKEN="${UPSTASH_REDIS_REST_TOKEN:-AS3JAAIjcDFlOGQ0YWIzOGYxYmU0MDU3YTlmZGFmYjI1NjQ1OGUwZHAxMA}"
              
              # Run garbage collection before tests to free memory
              node -e "if (global.gc) { global.gc(); global.gc(); global.gc(); }"
              
              # Run tests with memory and concurrency limits, using cloud Redis
              pnpm test --reporter=verbose --no-coverage --run --pool=threads --poolOptions.threads.minThreads=1 --poolOptions.threads.maxThreads=2
            displayName: Run tests with Upstash Redis
            continueOnError: true
            condition: succeededOrFailed()
            timeoutInMinutes: 30
            env:
              NODE_OPTIONS: "--max_old_space_size=4096 --expose-gc"
              REDIS_URL: $(REDIS_URL)
              UPSTASH_REDIS_REST_URL: $(UPSTASH_REDIS_REST_URL)
              UPSTASH_REDIS_REST_TOKEN: $(UPSTASH_REDIS_REST_TOKEN)
              TEST_TIMEOUT: "30000"
              VITEST_COVERAGE_ENABLED: "false"
              CI: "true"

          - task: PublishTestResults@2
            displayName: Publish test results
            condition: succeededOrFailed()
            inputs:
              testResultsFormat: JUnit
              testResultsFiles: '**/test-results.xml'
              failTaskOnFailedTests: false

          - task: PublishCodeCoverageResults@2
            displayName: Publish code coverage
            condition: succeededOrFailed()
            inputs:
              summaryFileLocation: '**/coverage/cobertura-coverage.xml'

          - script: |
              export NODE_ENV=production
              export ASTRO_CONFIG_FILE=astro.config.azure.mjs
              pnpm build
            displayName: Build application
            env:
              NODE_ENV: production
              ASTRO_CONFIG_FILE: astro.config.azure.mjs
              PUBLIC_SITE_URL: $(PUBLIC_SITE_URL)
              AZURE_STORAGE_CONTAINER_NAME: $(AZURE_STORAGE_CONTAINER_NAME)
              AZURE_RESOURCE_GROUP: $(resourceGroupName)
              AZURE_LOCATION: $(azureLocation)
              AZURE_SUBSCRIPTION_ID: $(azureSubscriptionId)
              AZURE_STATIC_WEB_APP_NAME: $(AZURE_STATIC_WEB_APP_NAME)
              AZURE_APP_SERVICE_NAME: $(appServiceName)
              AZURE_APP_SERVICE_PLAN: $(AZURE_APP_SERVICE_PLAN)
              AZURE_FUNCTIONS_NAME: $(AZURE_FUNCTIONS_NAME)
              AZURE_FUNCTIONS_STORAGE: $(AZURE_FUNCTIONS_STORAGE)

          - task: ArchiveFiles@2
            displayName: Archive build artifacts
            inputs:
              rootFolderOrFile: dist
              includeRootFolder: false
              archiveType: zip
              archiveFile: $(Build.ArtifactStagingDirectory)/app-$(Build.BuildId).zip

          - task: PublishBuildArtifacts@1
            displayName: Publish build artifacts
            inputs:
              pathToPublish: $(Build.ArtifactStagingDirectory)
              artifactName: drop

  # Docker Build Stage
  - stage: DockerBuild
    displayName: Build Docker Image
    dependsOn: Build
    condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/master'), eq(variables['Build.SourceBranch'], 'refs/heads/develop')))
    jobs:
      - job: DockerBuildJob
        displayName: Build and Push Docker Image
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - task: Docker@2
            displayName: Login to Azure Container Registry
            inputs:
              command: login
              containerRegistry: $(containerRegistryServiceConnection)

          - task: Docker@2
            displayName: Build Docker image
            inputs:
              command: build
              repository: $(imageName)
              dockerfile: Dockerfile.azure
              tags: |
                $(buildId)
                latest
              arguments: '--build-arg NODE_ENV=production'

          - task: Docker@2
            displayName: Push Docker image
            inputs:
              command: push
              containerRegistry: $(containerRegistryServiceConnection)
              repository: $(imageName)
              tags: |
                $(buildId)
                latest

          - script: |
              docker image prune -f
            displayName: Clean up Docker images

  # Infrastructure Deployment Stage
  - stage: Infrastructure
    displayName: Deploy Infrastructure
    dependsOn: []
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
    jobs:
      - deployment: InfrastructureDeployment
        displayName: Deploy Azure Infrastructure
        environment: 'azure-infrastructure'
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  displayName: Checkout source code

                - script: |
                    echo "üîç Updating Azure CLI and Bicep to latest versions..."
                    
                    # Force update Azure CLI to latest version to fix 'content already consumed' bug
                    echo "üîÑ Updating Azure CLI..."
                    curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
                    
                    # Force reinstall Bicep to latest version
                    echo "üì¶ Updating Bicep to latest version..."
                    az bicep uninstall || true
                    az bicep install
                    
                    # Configure Az CLI settings to prevent output issues
                    az config set core.output=json
                    az config set core.only_show_errors=true
                    
                    # Verify updated installations
                    echo "‚úÖ Verifying updated installations..."
                    echo "Azure CLI version:"
                    az --version | head -5
                    echo "Bicep version:"
                    az bicep version

                    echo "‚úÖ Azure CLI and Bicep update completed successfully!"
                  displayName: Update Azure CLI and Bicep
                - task: AzureCLI@2
                  displayName: Deploy Bicep template
                  inputs:
                    azureSubscription: $(azureSubscription)
                    scriptType: bash
                    scriptLocation: inlineScript
                    addSpnToEnvironment: true
                    failOnStandardError: false
                    workingDirectory: $(System.DefaultWorkingDirectory)
                    inlineScript: |
                      # Set strict error handling
                      set -euo pipefail

                      # Configure Azure CLI to prevent output consumption issues
                      export AZURE_CORE_OUTPUT=json
                      export AZURE_CORE_ONLY_SHOW_ERRORS=true
                      
                      # Disable interactive prompts
                      export AZURE_CORE_DISABLE_CONFIRM_PROMPT=1

                      # Verify tools are available after update
                      echo "üîç Verifying Azure CLI and Bicep after update..."
                      az --version | head -5
                      az bicep version

                      # Verify Bicep template exists
                      if [ ! -f "deploy/azure/main.bicep" ]; then
                        echo "‚ùå Bicep template not found at deploy/azure/main.bicep"
                        ls -la deploy/azure/ || echo "deploy/azure directory not found"
                        exit 1
                      fi

                      echo "‚úÖ Bicep template found, deploying infrastructure..."
                      echo "üìç Resource Group: $(resourceGroupName)"
                      echo "üåç Environment: $(environment)"

                      # Check if resource group exists, create if not
                      if ! az group show --name $(resourceGroupName) >/dev/null 2>&1; then
                        echo "üîß Creating resource group $(resourceGroupName)..."
                        az group create \
                          --name $(resourceGroupName) \
                          --location $(azureLocation) \
                          --output none
                      else
                        echo "‚úÖ Resource group $(resourceGroupName) already exists"
                      fi

                      # Deploy infrastructure using Bicep with improved error handling
                      echo "üöÄ Starting Bicep deployment..."
                      
                      # Function to attempt deployment with minimal output and fixed consumption bug
                      deploy_bicep() {
                        local attempt=$1
                        echo "üîÑ Deployment attempt $attempt..."
                        
                        # Use a unique deployment name to avoid conflicts
                        local deployment_name="main-$(date +%Y%m%d-%H%M%S)-$attempt"
                        
                        # Run deployment with no output to prevent content consumption issue
                        az deployment group create \
                          --resource-group $(resourceGroupName) \
                          --name "$deployment_name" \
                          --template-file deploy/azure/main.bicep \
                          --parameters \
                            appName=pixelated \
                            environment=$(environment) \
                            location=$(azureLocation) \
                            enableAzureOpenAI=true \
                            enableStorage=true \
                            enableMonitoring=true \
                          --output json \
                          --only-show-errors 2>/dev/null || return 1
                        
                        # Verify deployment success separately
                        local status=$(az deployment group show \
                          --resource-group $(resourceGroupName) \
                          --name "$deployment_name" \
                          --query "properties.provisioningState" \
                          --output tsv 2>/dev/null || echo "Failed")
                        
                        if [ "$status" = "Succeeded" ]; then
                          echo "‚úÖ Deployment $deployment_name completed successfully"
                          return 0
                        else
                          echo "‚ùå Deployment $deployment_name failed with status: $status"
                          return 1
                        fi
                      }
                      
                      # Retry logic for deployment
                      MAX_RETRIES=3
                      RETRY_COUNT=1
                      
                      while [ $RETRY_COUNT -le $MAX_RETRIES ]; do
                        if deploy_bicep $RETRY_COUNT; then
                          echo "‚úÖ Infrastructure deployment completed successfully"
                          exit 0
                        else
                          if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                            echo "‚ö†Ô∏è Deployment attempt $RETRY_COUNT failed, retrying in 30 seconds..."
                            sleep 30
                            RETRY_COUNT=$((RETRY_COUNT + 1))
                          else
                            echo "‚ùå All deployment attempts failed"
                            
                            # Show recent deployment errors for debugging
                            echo "üîç Recent deployment status:"
                            az deployment group list \
                              --resource-group $(resourceGroupName) \
                              --query "[?contains(name, 'main-')].{Name:name, State:properties.provisioningState, Timestamp:properties.timestamp}" \
                              --output table 2>/dev/null || echo "Could not retrieve deployment history"
                            
                            exit 1
                          fi
                        fi
                      done

  # Application Deployment Stage
  - stage: Deploy
    displayName: Deploy Application
    dependsOn:
      - Build
      - DockerBuild
    condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/master'), eq(variables['Build.SourceBranch'], 'refs/heads/develop')))
    jobs:
      - deployment: AppServiceDeployment
        displayName: Deploy to Azure App Service
        environment: azure-$(environment)
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: AzureWebAppContainer@1
                  displayName: Deploy to Azure Web App (Container)
                  inputs:
                    azureSubscription: $(azureSubscription)
                    resourceGroupName: $(resourceGroupName)
                    appName: $(appServiceName)
                    slotName: $(deploymentSlot)
                    imageName: $(containerRegistry)/$(imageName):$(buildId)

                - task: AzureAppServiceSettings@1
                  displayName: Configure App Service settings
                  inputs:
                    azureSubscription: $(azureSubscription)
                    appName: $(appServiceName)
                    resourceGroupName: $(resourceGroupName)
                    slotName: $(deploymentSlot)
                    appSettings: |
                      [
                        {
                          "name": "NODE_ENV",
                          "value": "$(environment)"
                        },
                        {
                          "name": "WEBSITES_PORT",
                          "value": "8080"
                        },
                        {
                          "name": "WEBSITES_ENABLE_APP_SERVICE_STORAGE",
                          "value": "false"
                        },
                        {
                          "name": "ASTRO_CONFIG_FILE",
                          "value": "astro.config.azure.mjs"
                        },
                        {
                          "name": "SCM_DO_BUILD_DURING_DEPLOYMENT",
                          "value": "false"
                        }
                      ]

  # Post-Deployment Testing
  - stage: PostDeploymentTests
    displayName: Post-Deployment Tests
    dependsOn: Deploy
    condition: succeeded()
    jobs:
      - job: HealthCheck
        displayName: Health Check
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - script: |
              echo "üîç Verifying Azure CLI for health checks..."
              
              # Verify Azure CLI is working (ubuntu-latest has it pre-installed)
              if ! command -v az &> /dev/null; then
                echo "‚ùå Azure CLI not found"
                exit 1
              fi
              
              echo "‚úÖ Azure CLI is available"
              az --version | head -5
              
              echo "Azure CLI verified successfully!"
            displayName: Verify Azure CLI

          - task: AzureCLI@2
            displayName: Get App Service URL
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: bash
              scriptLocation: inlineScript
              addSpnToEnvironment: true
              failOnStandardError: false
              inlineScript: |
                # Set error handling
                set -e

                # Verify Azure CLI is available
                echo "üîç Verifying Azure CLI..."
                az --version | head -5

                echo "üîç Getting App Service URL for $(appServiceName)..."
                APP_URL=$(az webapp show --name $(appServiceName) --resource-group $(resourceGroupName) --query "defaultHostName" --output tsv --only-show-errors)

                if [ -z "$APP_URL" ]; then
                  echo "‚ùå Failed to get App Service URL"
                  exit 1
                fi

                echo "‚úÖ App Service URL: https://$APP_URL"
                echo "##vso[task.setvariable variable=appUrl]https://$APP_URL"

          - script: |
              echo "Testing application health at: $(appUrl)"

              # Wait for application to be ready
              sleep 30

              # Health check for /api/health
              response=$(curl -s -o /dev/null -w "%{http_code}" $(appUrl)/api/health)
              if [ $response -eq 200 ]; then
                echo "‚úÖ /api/health check passed"
              else
                echo "‚ùå /api/health check failed with status: $response"
                exit 1
              fi

              # Health check for root /
              response=$(curl -s -o /dev/null -w "%{http_code}" $(appUrl))
              if [ $response -eq 200 ]; then
                echo "‚úÖ Root endpoint is responding"
              else
                echo "‚ùå Root endpoint not responding with status: $response"
                exit 1
              fi

              # Optionally, add more endpoint checks here
            displayName: Run health checks

          - task: PublishTestResults@2
            displayName: Publish health check results
            condition: always()
            inputs:
              testResultsFormat: JUnit
              testResultsFiles: '**/health-check-results.xml'
              failTaskOnFailedTests: true
