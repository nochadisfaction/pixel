# Azure DevOps Pipeline for Pixelated Empathy
#
trigger:
  branches:
    include:
      - master
      - develop
  paths:
    include:
      - src/**
      - deploy/azure/**
      - Dockerfile.azure
      - azure-pipelines.yml
      - .azure-pipelines/**
      - package.json
      - pnpm-lock.yaml

pr:
  branches:
    include:
      - master
      - develop

variables:
  # Build Configuration
  buildConfiguration: Release
  nodeVersion: 22.x

  # Azure Configuration
  azureSubscription: pixelated-service-connection
  resourceGroupName: pixelated-rg
  appServiceName: pixelated-app
  containerRegistry: pixelatedcr.azurecr.io
  containerRegistryServiceConnection: 'Azure Container Registry'
  imageName: pixelated-web

  # Azure Resource Configuration
  azureSubscriptionId: $(AZURE_SUBSCRIPTION_ID)
  azureStorageContainerName: $(AZURE_STORAGE_CONTAINER_NAME)
  publicSiteUrl: $(PUBLIC_SITE_URL)

  # Build specific variables
  buildId: $(Build.BuildId)
  buildNumber: $(Build.BuildNumber)

  # Environment Variables
  ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/master') }}:
    environment: production
    deploymentSlot: production
    azureLocation: eastus
  ${{ else }}:
    environment: staging
    deploymentSlot: staging
    azureLocation: eastus

stages:
  # Build Stage
  - stage: Build
    displayName: Build Application
    jobs:
      - job: BuildJob
        displayName: Build and Test
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - task: NodeTool@0
            displayName: Install Node.js
            inputs:
              versionSpec: $(nodeVersion)

          - task: Cache@2
            displayName: Cache pnpm dependencies
            inputs:
              key: pnpm | "$(Agent.OS)" | pnpm-lock.yaml
              restoreKeys: |
                pnpm | "$(Agent.OS)"
              path: $(Pipeline.Workspace)/.pnpm-store

          - script: |
              npm install -g pnpm
              pnpm config set store-dir $(Pipeline.Workspace)/.pnpm-store
              pnpm install --no-frozen-lockfile
            displayName: Install dependencies

          - script: |
              pnpm run lint:ci
            displayName: Run linting
            continueOnError: true
            condition: succeededOrFailed()
            env:
              PUBLIC_SITE_URL: $(PUBLIC_SITE_URL)
              AZURE_STORAGE_CONTAINER_NAME: $(AZURE_STORAGE_CONTAINER_NAME)
              AZURE_RESOURCE_GROUP: $(resourceGroupName)
              AZURE_LOCATION: $(azureLocation)
              AZURE_SUBSCRIPTION_ID: $(azureSubscriptionId)
              AZURE_STATIC_WEB_APP_NAME: $(AZURE_STATIC_WEB_APP_NAME)
              AZURE_APP_SERVICE_NAME: $(appServiceName)
              AZURE_APP_SERVICE_PLAN: $(AZURE_APP_SERVICE_PLAN)
              AZURE_FUNCTIONS_NAME: $(AZURE_FUNCTIONS_NAME)
              AZURE_FUNCTIONS_STORAGE: $(AZURE_FUNCTIONS_STORAGE)

          - script: |
              pnpm run type-check || echo "Type checking completed with warnings/errors but continuing build"
            displayName: Run type checking
            continueOnError: true
            condition: succeededOrFailed()
            env:
              PUBLIC_SITE_URL: $(PUBLIC_SITE_URL)
              AZURE_STORAGE_CONTAINER_NAME: $(AZURE_STORAGE_CONTAINER_NAME)
              AZURE_RESOURCE_GROUP: $(resourceGroupName)
              AZURE_LOCATION: $(azureLocation)
              AZURE_SUBSCRIPTION_ID: $(azureSubscriptionId)
              AZURE_STATIC_WEB_APP_NAME: $(AZURE_STATIC_WEB_APP_NAME)
              AZURE_APP_SERVICE_NAME: $(appServiceName)
              AZURE_APP_SERVICE_PLAN: $(AZURE_APP_SERVICE_PLAN)
              AZURE_FUNCTIONS_NAME: $(AZURE_FUNCTIONS_NAME)
              AZURE_FUNCTIONS_STORAGE: $(AZURE_FUNCTIONS_STORAGE)

          - script: |
              pnpm test
            displayName: Run tests
            continueOnError: true
            condition: succeededOrFailed()

          - task: PublishTestResults@2
            displayName: Publish test results
            condition: succeededOrFailed()
            inputs:
              testResultsFormat: JUnit
              testResultsFiles: '**/test-results.xml'
              failTaskOnFailedTests: false

          - task: PublishCodeCoverageResults@1
            displayName: Publish code coverage
            condition: succeededOrFailed()
            inputs:
              codeCoverageTool: Cobertura
              summaryFileLocation: '**/coverage/cobertura-coverage.xml'

          - script: |
              export NODE_ENV=production
              export ASTRO_CONFIG_FILE=astro.config.azure.mjs
              pnpm build
            displayName: Build application
            env:
              NODE_ENV: production
              ASTRO_CONFIG_FILE: astro.config.azure.mjs
              PUBLIC_SITE_URL: $(PUBLIC_SITE_URL)
              AZURE_STORAGE_CONTAINER_NAME: $(AZURE_STORAGE_CONTAINER_NAME)
              AZURE_RESOURCE_GROUP: $(resourceGroupName)
              AZURE_LOCATION: $(azureLocation)
              AZURE_SUBSCRIPTION_ID: $(azureSubscriptionId)
              AZURE_STATIC_WEB_APP_NAME: $(AZURE_STATIC_WEB_APP_NAME)
              AZURE_APP_SERVICE_NAME: $(appServiceName)
              AZURE_APP_SERVICE_PLAN: $(AZURE_APP_SERVICE_PLAN)
              AZURE_FUNCTIONS_NAME: $(AZURE_FUNCTIONS_NAME)
              AZURE_FUNCTIONS_STORAGE: $(AZURE_FUNCTIONS_STORAGE)

          - task: ArchiveFiles@2
            displayName: Archive build artifacts
            inputs:
              rootFolderOrFile: dist
              includeRootFolder: false
              archiveType: zip
              archiveFile: $(Build.ArtifactStagingDirectory)/app-$(Build.BuildId).zip

          - task: PublishBuildArtifacts@1
            displayName: Publish build artifacts
            inputs:
              pathToPublish: $(Build.ArtifactStagingDirectory)
              artifactName: drop

  # Docker Build Stage
  - stage: DockerBuild
    displayName: Build Docker Image
    dependsOn: Build
    condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/master'), eq(variables['Build.SourceBranch'], 'refs/heads/develop')))
    jobs:
      - job: DockerBuildJob
        displayName: Build and Push Docker Image
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - task: Docker@2
            displayName: Login to Azure Container Registry
            inputs:
              command: login
              containerRegistry: $(containerRegistryServiceConnection)

          - task: Docker@2
            displayName: Build Docker image
            inputs:
              command: build
              repository: $(imageName)
              dockerfile: Dockerfile.azure
              tags: |
                $(buildId)
                latest
              arguments: '--build-arg NODE_ENV=production'

          - task: Docker@2
            displayName: Push Docker image
            inputs:
              command: push
              containerRegistry: $(containerRegistryServiceConnection)
              repository: $(imageName)
              tags: |
                $(buildId)
                latest

          - script: |
              docker image prune -f
            displayName: Clean up Docker images

  # Infrastructure Deployment Stage
  - stage: Infrastructure
    displayName: Deploy Infrastructure
    dependsOn: []
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
    jobs:
      - deployment: InfrastructureDeployment
        displayName: Deploy Azure Infrastructure
        environment: 'azure-infrastructure'
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  displayName: Checkout source code

                - script: |
                    echo "üîç Verifying Azure CLI and Bicep..."
                    
                    # Verify Azure CLI is working (ubuntu-latest has it pre-installed)
                    if ! command -v az &> /dev/null; then
                      echo "‚ùå Azure CLI not found"
                      exit 1
                    fi
                    
                    echo "‚úÖ Azure CLI is available"
                    az --version

                    # Install/Update Bicep
                    echo "üì¶ Installing/Updating Bicep..."
                    az bicep install || echo "‚ö†Ô∏è Bicep install failed, continuing..."

                    # Verify Bicep installation
                    echo "‚úÖ Verifying Bicep installation..."
                    az bicep version || echo "‚ö†Ô∏è Bicep not available, but continuing..."

                    echo "‚úÖ Azure CLI and Bicep setup completed successfully!"
                  displayName: Verify Azure CLI and Install Bicep
                - task: AzureCLI@2
                  displayName: Deploy Bicep template
                  inputs:
                    azureSubscription: $(azureSubscription)
                    scriptType: bash
                    scriptLocation: inlineScript
                    addSpnToEnvironment: true
                    failOnStandardError: true
                    inlineScript: |
                      # Set error handling
                      set -e

                      # Verify tools are available
                      echo "üîç Verifying Azure CLI and Bicep..."
                      az --version
                      az bicep version

                      # Verify Bicep template exists
                      if [ ! -f "deploy/azure/main.bicep" ]; then
                        echo "‚ùå Bicep template not found at deploy/azure/main.bicep"
                        ls -la deploy/azure/ || echo "deploy/azure directory not found"
                        exit 1
                      fi

                      echo "‚úÖ Bicep template found, deploying infrastructure..."
                      echo "üìç Resource Group: $(resourceGroupName)"
                      echo "üåç Environment: $(environment)"

                      # Check if resource group exists, create if not
                      if ! az group show --name $(resourceGroupName) --output none 2>/dev/null; then
                        echo "üîß Creating resource group $(resourceGroupName)..."
                        az group create --name $(resourceGroupName) --location $(azureLocation)
                      fi

                      # Deploy infrastructure using Bicep
                      echo "üöÄ Starting Bicep deployment..."
                      az deployment group create \
                        --resource-group $(resourceGroupName) \
                        --template-file deploy/azure/main.bicep \
                        --parameters \
                          appName=pixelated \
                          environment=$(environment) \
                          location=$(azureLocation) \
                          enableAzureOpenAI=true \
                          enableStorage=true \
                          enableMonitoring=true \
                        --verbose \
                        --output table

                      echo "‚úÖ Infrastructure deployment completed successfully"

  # Application Deployment Stage
  - stage: Deploy
    displayName: Deploy Application
    dependsOn:
      - Build
      - DockerBuild
    condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/master'), eq(variables['Build.SourceBranch'], 'refs/heads/develop')))
    jobs:
      - deployment: AppServiceDeployment
        displayName: Deploy to Azure App Service
        environment: azure-$(environment)
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: AzureWebAppContainer@1
                  displayName: Deploy to Azure Web App (Container)
                  inputs:
                    azureSubscription: $(azureSubscription)
                    resourceGroupName: $(resourceGroupName)
                    appName: $(appServiceName)
                    slotName: $(deploymentSlot)
                    imageName: $(containerRegistry)/$(imageName):$(buildId)

                - task: AzureAppServiceSettings@1
                  displayName: Configure App Service settings
                  inputs:
                    azureSubscription: $(azureSubscription)
                    appName: $(appServiceName)
                    resourceGroupName: $(resourceGroupName)
                    slotName: $(deploymentSlot)
                    appSettings: |
                      [
                        {
                          "name": "NODE_ENV",
                          "value": "$(environment)"
                        },
                        {
                          "name": "WEBSITES_PORT",
                          "value": "8080"
                        },
                        {
                          "name": "WEBSITES_ENABLE_APP_SERVICE_STORAGE",
                          "value": "false"
                        },
                        {
                          "name": "ASTRO_CONFIG_FILE",
                          "value": "astro.config.azure.mjs"
                        },
                        {
                          "name": "SCM_DO_BUILD_DURING_DEPLOYMENT",
                          "value": "false"
                        }
                      ]

  # Post-Deployment Testing
  - stage: PostDeploymentTests
    displayName: Post-Deployment Tests
    dependsOn: Deploy
    condition: succeeded()
    jobs:
      - job: HealthCheck
        displayName: Health Check
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - script: |
              echo "üîç Verifying Azure CLI for health checks..."
              
              # Verify Azure CLI is working (ubuntu-latest has it pre-installed)
              if ! command -v az &> /dev/null; then
                echo "‚ùå Azure CLI not found"
                exit 1
              fi
              
              echo "‚úÖ Azure CLI is available"
              az --version
              
              echo "Azure CLI verified successfully!"
            displayName: Verify Azure CLI

          - task: AzureCLI@2
            displayName: Get App Service URL
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: bash
              scriptLocation: inlineScript
              addSpnToEnvironment: true
              failOnStandardError: true
              inlineScript: |
                # Set error handling
                set -e

                # Verify Azure CLI is available
                echo "üîç Verifying Azure CLI..."
                az --version

                echo "üîç Getting App Service URL for $(appServiceName)..."
                APP_URL=$(az webapp show --name $(appServiceName) --resource-group $(resourceGroupName) --query "defaultHostName" --output tsv)

                if [ -z "$APP_URL" ]; then
                  echo "‚ùå Failed to get App Service URL"
                  exit 1
                fi

                echo "‚úÖ App Service URL: https://$APP_URL"
                echo "##vso[task.setvariable variable=appUrl]https://$APP_URL"

          - script: |
              echo "Testing application health at: $(appUrl)"

              # Wait for application to be ready
              sleep 30

              # Health check for /api/health
              response=$(curl -s -o /dev/null -w "%{http_code}" $(appUrl)/api/health)
              if [ $response -eq 200 ]; then
                echo "‚úÖ /api/health check passed"
              else
                echo "‚ùå /api/health check failed with status: $response"
                exit 1
              fi

              # Health check for root /
              response=$(curl -s -o /dev/null -w "%{http_code}" $(appUrl))
              if [ $response -eq 200 ]; then
                echo "‚úÖ Root endpoint is responding"
              else
                echo "‚ùå Root endpoint not responding with status: $response"
                exit 1
              fi

              # Optionally, add more endpoint checks here
            displayName: Run health checks

          - task: PublishTestResults@2
            displayName: Publish health check results
            condition: always()
            inputs:
              testResultsFormat: JUnit
              testResultsFiles: '**/health-check-results.xml'
              failTaskOnFailedTests: true
