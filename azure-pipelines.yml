# Azure DevOps Pipeline for Pixelated Empathy
#
trigger:
  branches:
    include:
      - master
      - develop
  paths:
    include:
      - src/**
      - deploy/azure/**
      - Dockerfile.azure
      - azure-pipelines.yml
      - .azure-pipelines/**
      - package.json
      - pnpm-lock.yaml

pr:
  branches:
    include:
      - master
      - develop

variables:
  # Build Configuration
  buildConfiguration: Release
  nodeVersion: 22.x

  # Azure Configuration
  azureSubscription: 'pixelated-service-connection'
  resourceGroupName: $(AZURE_RESOURCE_GROUP)
  appServiceName: $(AZURE_APP_SERVICE_NAME)
  containerRegistry: $(AZURE_CONTAINER_REGISTRY)
  containerRegistryServiceConnection: 'Azure Container Registry'
  imageName: pixelated-web

  # Azure Resource Configuration
  azureSubscriptionId: $(AZURE_SUBSCRIPTION_ID)
  azureStorageContainerName: $(AZURE_STORAGE_CONTAINER_NAME)
  publicSiteUrl: $(PUBLIC_SITE_URL)

  # Build specific variables
  buildId: $(Build.BuildId)
  buildNumber: $(Build.BuildNumber)

  # Environment Variables
  ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/master') }}:
    environment: production
    deploymentSlot: production
    azureLocation: $(AZURE_LOCATION)
  ${{ else }}:
    environment: staging
    deploymentSlot: staging
    azureLocation: $(AZURE_LOCATION)

stages:
  # Build Stage
  - stage: Build
    displayName: Build Application
    jobs:
      - job: BuildJob
        displayName: Build and Test
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - task: NodeTool@0
            displayName: Install Node.js
            inputs:
              versionSpec: $(nodeVersion)

          - task: Cache@2
            displayName: Cache pnpm dependencies
            inputs:
              key: pnpm | "$(Agent.OS)" | pnpm-lock.yaml
              restoreKeys: |
                pnpm | "$(Agent.OS)"
              path: $(Pipeline.Workspace)/.pnpm-store

          - script: |
              npm install -g pnpm
              pnpm config set store-dir $(Pipeline.Workspace)/.pnpm-store
              pnpm install --no-frozen-lockfile
            displayName: Install dependencies

          - script: |
              pnpm run lint:ci
            displayName: Run linting
            continueOnError: true
            condition: succeededOrFailed()
            env:
              PUBLIC_SITE_URL: $(PUBLIC_SITE_URL)
              AZURE_STORAGE_CONTAINER_NAME: $(AZURE_STORAGE_CONTAINER_NAME)
              AZURE_RESOURCE_GROUP: $(resourceGroupName)
              AZURE_LOCATION: $(azureLocation)
              AZURE_SUBSCRIPTION_ID: $(azureSubscriptionId)
              AZURE_STATIC_WEB_APP_NAME: $(AZURE_STATIC_WEB_APP_NAME)
              AZURE_APP_SERVICE_NAME: $(appServiceName)
              AZURE_APP_SERVICE_PLAN: $(AZURE_APP_SERVICE_PLAN)
              AZURE_FUNCTIONS_NAME: $(AZURE_FUNCTIONS_NAME)
              AZURE_FUNCTIONS_STORAGE: $(AZURE_FUNCTIONS_STORAGE)

          - script: |
              pnpm run type-check || echo "Type checking completed with warnings/errors but continuing build"
            displayName: Run type checking
            continueOnError: true
            condition: succeededOrFailed()
            env:
              PUBLIC_SITE_URL: $(PUBLIC_SITE_URL)
              AZURE_STORAGE_CONTAINER_NAME: $(AZURE_STORAGE_CONTAINER_NAME)
              AZURE_RESOURCE_GROUP: $(resourceGroupName)
              AZURE_LOCATION: $(azureLocation)
              AZURE_SUBSCRIPTION_ID: $(azureSubscriptionId)
              AZURE_STATIC_WEB_APP_NAME: $(AZURE_STATIC_WEB_APP_NAME)
              AZURE_APP_SERVICE_NAME: $(appServiceName)
              AZURE_APP_SERVICE_PLAN: $(AZURE_APP_SERVICE_PLAN)
              AZURE_FUNCTIONS_NAME: $(AZURE_FUNCTIONS_NAME)
              AZURE_FUNCTIONS_STORAGE: $(AZURE_FUNCTIONS_STORAGE)

          - script: |
              # Set memory limits and test configuration for CI
              export NODE_OPTIONS="--max_old_space_size=4096 --expose-gc"
              export TEST_TIMEOUT="30000"
              export VITEST_MIN_THREADS="1"
              export VITEST_MAX_THREADS="2"
              export CI="true"
              
              # Use Upstash Redis from environment variables
              export REDIS_URL="${REDIS_URL:-rediss://default:AS3JAAIjcDFlOGQ0YWIzOGYxYmU0MDU3YTlmZGFmYjI1NjQ1OGUwZHAxMA@neutral-ray-11721.upstash.io:6379}"
              export UPSTASH_REDIS_REST_URL="${UPSTASH_REDIS_REST_URL:-https://neutral-ray-11721.upstash.io}"
              export UPSTASH_REDIS_REST_TOKEN="${UPSTASH_REDIS_REST_TOKEN:-AS3JAAIjcDFlOGQ0YWIzOGYxYmU0MDU3YTlmZGFmYjI1NjQ1OGUwZHAxMA}"
              
              # Run garbage collection before tests to free memory
              node -e "if (global.gc) { global.gc(); global.gc(); global.gc(); }"
              
              # Run tests with memory and concurrency limits, using cloud Redis
              pnpm test --reporter=verbose --no-coverage --run --pool=threads --poolOptions.threads.minThreads=1 --poolOptions.threads.maxThreads=2
            displayName: Run tests with Upstash Redis
            continueOnError: true
            condition: succeededOrFailed()
            timeoutInMinutes: 30
            env:
              NODE_OPTIONS: "--max_old_space_size=4096 --expose-gc"
              REDIS_URL: $(REDIS_URL)
              UPSTASH_REDIS_REST_URL: $(UPSTASH_REDIS_REST_URL)
              UPSTASH_REDIS_REST_TOKEN: $(UPSTASH_REDIS_REST_TOKEN)
              TEST_TIMEOUT: "30000"
              VITEST_COVERAGE_ENABLED: "false"
              CI: "true"

          - task: PublishTestResults@2
            displayName: Publish test results
            condition: succeededOrFailed()
            inputs:
              testResultsFormat: JUnit
              testResultsFiles: '**/test-results.xml'
              failTaskOnFailedTests: false

          - task: PublishCodeCoverageResults@2
            displayName: Publish code coverage
            condition: succeededOrFailed()
            inputs:
              summaryFileLocation: '**/coverage/cobertura-coverage.xml'

          - script: |
              export NODE_ENV=production
              export ASTRO_CONFIG_FILE=astro.config.azure.mjs
              pnpm build
            displayName: Build application
            env:
              NODE_ENV: production
              ASTRO_CONFIG_FILE: astro.config.azure.mjs
              PUBLIC_SITE_URL: $(PUBLIC_SITE_URL)
              AZURE_STORAGE_CONTAINER_NAME: $(AZURE_STORAGE_CONTAINER_NAME)
              AZURE_RESOURCE_GROUP: $(resourceGroupName)
              AZURE_LOCATION: $(azureLocation)
              AZURE_SUBSCRIPTION_ID: $(azureSubscriptionId)
              AZURE_STATIC_WEB_APP_NAME: $(AZURE_STATIC_WEB_APP_NAME)
              AZURE_APP_SERVICE_NAME: $(appServiceName)
              AZURE_APP_SERVICE_PLAN: $(AZURE_APP_SERVICE_PLAN)
              AZURE_FUNCTIONS_NAME: $(AZURE_FUNCTIONS_NAME)
              AZURE_FUNCTIONS_STORAGE: $(AZURE_FUNCTIONS_STORAGE)

          - task: ArchiveFiles@2
            displayName: Archive build artifacts
            inputs:
              rootFolderOrFile: dist
              includeRootFolder: false
              archiveType: zip
              archiveFile: $(Build.ArtifactStagingDirectory)/app-$(Build.BuildId).zip

          - task: PublishBuildArtifacts@1
            displayName: Publish build artifacts
            inputs:
              pathToPublish: $(Build.ArtifactStagingDirectory)
              artifactName: drop

  # Docker Build Stage
  - stage: DockerBuild
    displayName: Build Docker Image
    dependsOn: Build
    condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/master'), eq(variables['Build.SourceBranch'], 'refs/heads/develop')))
    jobs:
      - job: DockerBuildJob
        displayName: Build and Push Docker Image
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - task: Docker@2
            displayName: Login to Azure Container Registry
            inputs:
              command: login
              containerRegistry: $(containerRegistryServiceConnection)

          - task: Docker@2
            displayName: Build Docker image
            inputs:
              command: build
              repository: $(imageName)
              dockerfile: Dockerfile.azure
              tags: |
                $(buildId)
                latest
              arguments: '--build-arg NODE_ENV=production'

          - task: Docker@2
            displayName: Push Docker image
            inputs:
              command: push
              containerRegistry: $(containerRegistryServiceConnection)
              repository: $(imageName)
              tags: |
                $(buildId)
                latest

          - script: |
              docker image prune -f
            displayName: Clean up Docker images

  # Infrastructure Deployment Stage
  - stage: Infrastructure
    displayName: Deploy Infrastructure
    dependsOn: []
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
    jobs:
      - deployment: InfrastructureDeployment
        displayName: Deploy Azure Infrastructure
        environment: 'azure-infrastructure'
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  displayName: Checkout source code

                - script: |
                    echo "üîç Updating Azure CLI and Bicep to latest versions..."
                    
                    # Force update Azure CLI to latest version to fix 'content already consumed' bug
                    echo "üîÑ Updating Azure CLI..."
                    curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
                    
                    # Force reinstall Bicep to latest version
                    echo "üì¶ Updating Bicep to latest version..."
                    az bicep uninstall || true
                    az bicep install
                    
                    # Configure Az CLI settings to prevent output issues
                    az config set core.output=json
                    az config set core.only_show_errors=true
                    
                    # Clear any Azure CLI cache to prevent response consumption issues
                    az cache purge || true
                    
                    # Verify updated installations
                    echo "‚úÖ Verifying updated installations..."
                    echo "Azure CLI version:"
                    az --version | head -5
                    echo "Bicep version:"
                    az bicep version

                    echo "‚úÖ Azure CLI and Bicep update completed successfully!"
                  displayName: Update Azure CLI and Bicep
                - task: AzureCLI@2
                  displayName: Deploy Bicep template
                  inputs:
                    azureSubscription: $(azureSubscription)
                    scriptType: bash
                    scriptLocation: inlineScript
                    addSpnToEnvironment: true
                    failOnStandardError: false
                    workingDirectory: $(System.DefaultWorkingDirectory)
                    inlineScript: |
                      # Set strict error handling
                      set -euo pipefail

                      # Configure Azure CLI to prevent output consumption issues
                      export AZURE_CORE_OUTPUT=json
                      export AZURE_CORE_ONLY_SHOW_ERRORS=true
                      
                      # Disable interactive prompts
                      export AZURE_CORE_DISABLE_CONFIRM_PROMPT=1

                      # Clear any cached Azure CLI data to prevent issues
                      az cache purge || true

                      # Verify tools are available after update
                      echo "üîç Verifying Azure CLI and Bicep after update..."
                      az --version | head -5
                      az bicep version

                      # Verify Bicep template exists
                      if [ ! -f "deploy/azure/main.bicep" ]; then
                        echo "‚ùå Bicep template not found at deploy/azure/main.bicep"
                        ls -la deploy/azure/ || echo "deploy/azure directory not found"
                        exit 1
                      fi

                      echo "‚úÖ Bicep template found, deploying infrastructure..."
                      echo "üìç Resource Group: $(resourceGroupName)"
                      echo "üåç Environment: $(environment)"

                      # Check if resource group exists, create if not
                      if ! az group show --name $(resourceGroupName) --only-show-errors >/dev/null 2>&1; then
                        echo "üîß Creating resource group $(resourceGroupName)..."
                        az group create \
                          --name $(resourceGroupName) \
                          --location $(azureLocation) \
                          --only-show-errors \
                          --output none
                      else
                        echo "‚úÖ Resource group $(resourceGroupName) already exists"
                      fi

                      # Function to deploy Bicep with improved error handling
                      deploy_bicep_safe() {
                        ATTEMPT_NUM=$1
                        echo "üîÑ Deployment attempt $ATTEMPT_NUM..."
                        
                        # Use a unique deployment name to avoid conflicts
                        DEPLOYMENT_NAME="main-$(date +%Y%m%d-%H%M%S)-$ATTEMPT_NUM"
                        
                        echo "üìã Deployment parameters:"
                        echo "  - Resource Group: $(resourceGroupName)"
                        echo "  - App Name: $(AZURE_APP_NAME)"
                        echo "  - Environment: $(environment)"
                        echo "  - Location: $(azureLocation)"
                        echo "  - Azure OpenAI: false"
                        echo "  - Storage: true"
                        echo "  - Monitoring: true"
                        
                        # Start deployment with no-wait to prevent content consumption bug
                        echo "üöÄ Starting deployment: $DEPLOYMENT_NAME"
                        
                        # Use separate command to start deployment
                        if az deployment group create \
                          --resource-group $(resourceGroupName) \
                          --name "$DEPLOYMENT_NAME" \
                          --template-file deploy/azure/main.bicep \
                          --parameters \
                            appName=$(AZURE_APP_NAME) \
                            environment=$(environment) \
                            location=$(azureLocation) \
                            enableAzureOpenAI=false \
                            enableStorage=true \
                            enableMonitoring=true \
                          --no-wait \
                          --only-show-errors \
                          --output none; then
                          
                          echo "‚úÖ Deployment started successfully"
                          
                          # Poll deployment status to avoid content consumption
                          MAX_WAIT_MINUTES=15
                          WAIT_SECONDS=30
                          ELAPSED_MINUTES=0
                          
                          while [ $ELAPSED_MINUTES -lt $MAX_WAIT_MINUTES ]; do
                            echo "‚è±Ô∏è  Checking deployment status (${ELAPSED_MINUTES}/${MAX_WAIT_MINUTES} minutes)..."
                            
                            # Use separate CLI call to check status
                            STATUS=$(az deployment group show \
                              --resource-group $(resourceGroupName) \
                              --name "$DEPLOYMENT_NAME" \
                              --query "properties.provisioningState" \
                              --output tsv \
                              --only-show-errors 2>/dev/null || echo "Unknown")
                            
                            case "$STATUS" in
                              "Succeeded")
                                echo "‚úÖ Deployment $DEPLOYMENT_NAME completed successfully!"
                                
                                # Get deployment outputs if any
                                echo "üìã Deployment outputs:"
                                az deployment group show \
                                  --resource-group $(resourceGroupName) \
                                  --name "$DEPLOYMENT_NAME" \
                                  --query "properties.outputs" \
                                  --output table \
                                  --only-show-errors 2>/dev/null || echo "No outputs available"
                                
                                return 0
                                ;;
                              "Failed")
                                echo "‚ùå Deployment $DEPLOYMENT_NAME failed!"
                                
                                # Get error details with separate CLI call
                                echo "üîç Deployment error details:"
                                az deployment group show \
                                  --resource-group $(resourceGroupName) \
                                  --name "$DEPLOYMENT_NAME" \
                                  --query "properties.error" \
                                  --output json \
                                  --only-show-errors 2>/dev/null || echo "Could not retrieve error details"
                                
                                return 1
                                ;;
                              "Canceled")
                                echo "‚ö†Ô∏è Deployment $DEPLOYMENT_NAME was canceled"
                                return 1
                                ;;
                              "Running"|"Accepted"|"Creating")
                                echo "üîÑ Deployment in progress (status: $STATUS)..."
                                ;;
                              *)
                                echo "‚ö†Ô∏è Unknown deployment status: $STATUS"
                                ;;
                            esac
                            
                            # Wait before next check
                            sleep $WAIT_SECONDS
                            ELAPSED_MINUTES=$((ELAPSED_MINUTES + 1))
                          done
                          
                          # Timeout reached
                          echo "‚è∞ Deployment timeout reached (${MAX_WAIT_MINUTES} minutes)"
                          echo "üîç Final deployment status:"
                          az deployment group show \
                            --resource-group $(resourceGroupName) \
                            --name "$DEPLOYMENT_NAME" \
                            --query "{Name:name, Status:properties.provisioningState, Duration:properties.duration}" \
                            --output table \
                            --only-show-errors 2>/dev/null || echo "Could not retrieve final status"
                          
                          return 1
                        else
                          echo "‚ùå Failed to start deployment with exit code: $?"
                          return 1
                        fi
                      }
                      
                      # Deploy infrastructure with reduced retries due to improved async handling
                      MAX_RETRIES=2
                      RETRY_COUNT=1
                      
                      while [ $RETRY_COUNT -le $MAX_RETRIES ]; do
                        if deploy_bicep_safe $RETRY_COUNT; then
                          echo "‚úÖ Infrastructure deployment completed successfully"
                          
                          # Show final deployment summary
                          echo "üìä Deployment Summary:"
                          az deployment group list \
                            --resource-group $(resourceGroupName) \
                            --query "[?contains(name, 'main-')].{Name:name, State:properties.provisioningState, Timestamp:properties.timestamp}" \
                            --output table \
                            --only-show-errors 2>/dev/null || echo "Could not retrieve deployment summary"
                          
                          exit 0
                        else
                          if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                            echo "‚ö†Ô∏è Deployment attempt $RETRY_COUNT failed, retrying in 60 seconds..."
                            echo "üßπ Cleaning up failed deployment before retry..."
                            
                            # Cancel any running deployments before retry to avoid conflicts
                            FAILED_DEPLOYMENT="main-$(date +%Y%m%d-%H%M%S)-$RETRY_COUNT"
                            echo "üõë Canceling failed deployment if still running..."
                            az deployment group cancel \
                              --resource-group $(resourceGroupName) \
                              --name "$FAILED_DEPLOYMENT" \
                              --only-show-errors 2>/dev/null || echo "No deployment to cancel"
                            
                            sleep 60
                            RETRY_COUNT=$((RETRY_COUNT + 1))
                          else
                            echo "‚ùå All deployment attempts failed after $MAX_RETRIES attempts"
                            
                            # Enhanced debugging information
                            echo "üîç Comprehensive deployment analysis:"
                            echo "Recent deployments:"
                            az deployment group list \
                              --resource-group $(resourceGroupName) \
                              --query "[?contains(name, 'main-')].{Name:name, State:properties.provisioningState, Timestamp:properties.timestamp, Duration:properties.duration}" \
                              --output table \
                              --only-show-errors 2>/dev/null || echo "Could not retrieve deployment history"
                            
                            echo "Resource group resources:"
                            az resource list \
                              --resource-group $(resourceGroupName) \
                              --query "[].{Name:name, Type:type, Location:location}" \
                              --output table \
                              --only-show-errors 2>/dev/null || echo "Could not retrieve resource list"
                            
                            exit 1
                          fi
                        fi
                      done

  # Application Deployment Stage
  - stage: Deploy
    displayName: Deploy Application
    dependsOn:
      - Build
      - DockerBuild
    condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/master'), eq(variables['Build.SourceBranch'], 'refs/heads/develop')))
    jobs:
      - deployment: AppServiceDeployment
        displayName: Deploy to Azure App Service
        environment: azure-$(environment)
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: AzureWebAppContainer@1
                  displayName: Deploy to Azure Web App (Container)
                  inputs:
                    azureSubscription: $(azureSubscription)
                    resourceGroupName: $(resourceGroupName)
                    appName: $(appServiceName)
                    slotName: $(deploymentSlot)
                    imageName: $(containerRegistry)/$(imageName):$(buildId)

                - task: AzureAppServiceSettings@1
                  displayName: Configure App Service settings
                  inputs:
                    azureSubscription: $(azureSubscription)
                    appName: $(appServiceName)
                    resourceGroupName: $(resourceGroupName)
                    slotName: $(deploymentSlot)
                    appSettings: |
                      [
                        {
                          "name": "NODE_ENV",
                          "value": "$(environment)"
                        },
                        {
                          "name": "WEBSITES_PORT",
                          "value": "8080"
                        },
                        {
                          "name": "WEBSITES_ENABLE_APP_SERVICE_STORAGE",
                          "value": "false"
                        },
                        {
                          "name": "ASTRO_CONFIG_FILE",
                          "value": "astro.config.azure.mjs"
                        },
                        {
                          "name": "SCM_DO_BUILD_DURING_DEPLOYMENT",
                          "value": "false"
                        }
                      ]

  # Post-Deployment Testing
  - stage: PostDeploymentTests
    displayName: Post-Deployment Tests
    dependsOn: Deploy
    condition: succeeded()
    jobs:
      - job: HealthCheck
        displayName: Health Check
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - script: |
              echo "üîç Verifying Azure CLI for health checks..."
              
              # Verify Azure CLI is working (ubuntu-latest has it pre-installed)
              if ! command -v az &> /dev/null; then
                echo "‚ùå Azure CLI not found"
                exit 1
              fi
              
              echo "‚úÖ Azure CLI is available"
              az --version | head -5
              
              echo "Azure CLI verified successfully!"
            displayName: Verify Azure CLI

          - task: AzureCLI@2
            displayName: Get App Service URL
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: bash
              scriptLocation: inlineScript
              addSpnToEnvironment: true
              failOnStandardError: false
              inlineScript: |
                # Set error handling
                set -e

                # Verify Azure CLI is available
                echo "üîç Verifying Azure CLI..."
                az --version | head -5

                echo "üîç Getting App Service URL for $(appServiceName)..."
                APP_URL=$(az webapp show --name $(appServiceName) --resource-group $(resourceGroupName) --query "defaultHostName" --output tsv --only-show-errors)

                if [ -z "$APP_URL" ]; then
                  echo "‚ùå Failed to get App Service URL"
                  exit 1
                fi

                echo "‚úÖ App Service URL: https://$APP_URL"
                echo "##vso[task.setvariable variable=appUrl]https://$APP_URL"

          - script: |
              echo "Testing application health at: $(appUrl)"

              # Wait for application to be ready
              sleep 30

              # Health check for /api/health
              response=$(curl -s -o /dev/null -w "%{http_code}" $(appUrl)/api/health)
              if [ $response -eq 200 ]; then
                echo "‚úÖ /api/health check passed"
              else
                echo "‚ùå /api/health check failed with status: $response"
                exit 1
              fi

              # Health check for root /
              response=$(curl -s -o /dev/null -w "%{http_code}" $(appUrl))
              if [ $response -eq 200 ]; then
                echo "‚úÖ Root endpoint is responding"
              else
                echo "‚ùå Root endpoint not responding with status: $response"
                exit 1
              fi

              # Optionally, add more endpoint checks here
            displayName: Run health checks

          - task: PublishTestResults@2
            displayName: Publish health check results
            condition: always()
            inputs:
              testResultsFormat: JUnit
              testResultsFiles: '**/health-check-results.xml'
              failTaskOnFailedTests: true
