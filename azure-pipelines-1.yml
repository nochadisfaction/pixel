trigger:
  branches:
    include:
      - master
      - develop
  paths:
    exclude:
      - README.md
      - docs/*
      - .gitignore
pr:
  branches:
    include:
      - master
      - develop
variables:
  - name: buildConfiguration
    value: Release
  - name: nodeVersion
    value: 22
  - name: azureSubscription
    value: pixelated-service-connection
  - name: resourceGroupName
    value: pixelated-rg
  - name: appServiceName
    value: pixelated-app
  - name: containerRegistry
    value: pixelatedcr.azurecr.io
  - name: imageName
    value: pixelated-web
  - name: environment
    value: production
  - name: deploymentSlot
    value: production
stages:
  - stage: Build
    displayName: Build Application
    jobs:
      - job: BuildJob
        displayName: Build and Test
        pool:
          name: Default
        steps:
          - task: NodeTool@0
            displayName: Install Node.js
            inputs:
              versionSpec: $(nodeVersion)
          - task: Cache@2
            displayName: Cache pnpm dependencies
            inputs:
              key: pnpm | "$(Agent.OS)" | pnpm-lock.yaml
              restoreKeys: |
                pnpm | "$(Agent.OS)"
              path: $(Pipeline.Workspace)/.pnpm-store
          - task: CmdLine@2
            displayName: Install dependencies
            inputs:
              script: |
                npm install -g pnpm
                pnpm config set store-dir $(Pipeline.Workspace)/.pnpm-store
                pnpm install --no-frozen-lockfile
          - task: CmdLine@2
            displayName: Run linting
            continueOnError: true
            inputs:
              script: |
                pnpm run lint
          - task: CmdLine@2
            displayName: Run type checking
            continueOnError: true
            inputs:
              script: |
                pnpm run type-check
          - task: CmdLine@2
            displayName: Run tests
            continueOnError: true
            inputs:
              script: |
                pnpm test
          - task: PublishTestResults@2
            displayName: Publish test results
            condition: succeededOrFailed()
            inputs:
              testResultsFormat: JUnit
              testResultsFiles: '**/test-results.xml'
              failTaskOnFailedTests: false
          - task: PublishCodeCoverageResults@1
            displayName: Publish code coverage
            condition: succeededOrFailed()
            inputs:
              codeCoverageTool: Cobertura
              summaryFileLocation: '**/coverage/cobertura-coverage.xml'
          - task: CmdLine@2
            displayName: Build application
            env:
              NODE_ENV: production
            inputs:
              script: |
                export NODE_ENV=production
                export ASTRO_CONFIG_FILE=astro.config.mjs
                pnpm build
          - task: ArchiveFiles@2
            displayName: Archive build artifacts
            inputs:
              rootFolderOrFile: dist
              includeRootFolder: false
              archiveType: zip
              archiveFile: $(Build.ArtifactStagingDirectory)/app-$(Build.BuildId).zip
          - task: PublishBuildArtifacts@1
            displayName: Publish build artifacts
            inputs:
              pathToPublish: $(Build.ArtifactStagingDirectory)
              artifactName: drop
  - stage: DockerBuild
    displayName: Build Docker Image
    dependsOn:
      - Build
    condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/master'), eq(variables['Build.SourceBranch'], 'refs/heads/develop')))
    jobs:
      - job: DockerBuildJob
        displayName: Build and Push Docker Image
        pool:
          name: Default
        steps:
          - task: Docker@2
            displayName: Login to Azure Container Registry
            inputs:
              command: login
              containerRegistry: 'Azure Container Registry'
          - task: Docker@2
            displayName: Build Docker image
            inputs:
              command: build
              repository: $(imageName)
              dockerfile: Dockerfile.azure
              tags: |
                latest
          - task: Docker@2
            displayName: Push Docker image
            inputs:
              command: push
              repository: $(imageName)
              tags: |
                latest
          - task: CmdLine@2
            displayName: Clean up Docker images
            inputs:
              script: |
                docker image prune -f
  - stage: Infrastructure
    displayName: Deploy Infrastructure
    dependsOn: []
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
    jobs:
      - deployment: InfrastructureDeployment
        displayName: Deploy Azure Infrastructure
        environment:
          name: azure-infrastructure
        pool:
          name: Default
        strategy:
          runOnce:
            deploy:
              steps:
                # Add Azure CLI installation step
                - script: |
                    curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
                    az --version
                  displayName: 'Install Azure CLI'
                - task: AzureCLI@2
                  displayName: Deploy Bicep template
                  inputs:
                    azureSubscription: $(azureSubscription)
                    scriptType: bash
                    scriptLocation: inlineScript
                    inlineScript: |
                      # Deploy infrastructure using Bicep
                      az deployment group create \
                        --resource-group $(resourceGroupName) \
                        --template-file deploy/azure/main.bicep \
                        --parameters \
                          appName=pixelated \
                          environment=$(environment) \
                          location=eastus \
                          enableAzureOpenAI=true \
                          enableStorage=true \
                          enableMonitoring=true
  - stage: Deploy
    displayName: Deploy Application
    dependsOn:
      - Build
      - DockerBuild
    condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/master'), eq(variables['Build.SourceBranch'], 'refs/heads/develop')))
    jobs:
      - deployment: AppServiceDeployment
        displayName: Deploy to Azure App Service
        environment:
          name: azure-$(environment)
        pool:
          name: Default
        strategy:
          runOnce:
            deploy:
              steps:
                - task: AzureWebAppContainer@1
                  displayName: Deploy to Azure Web App (Container)
                  inputs:
                    azureSubscription: $(azureSubscription)
                    resourceGroupName: $(resourceGroupName)
                    appName: $(appServiceName)
                    slotName: $(deploymentSlot)
                    imageName: $(containerRegistry)/$(imageName):latest
                    configurationStrings: |
                      WEBSITES_PORT=8080
                      NODE_ENV=$(environment)
                      WEBSITES_ENABLE_APP_SERVICE_STORAGE=false
  - stage: PostDeploymentTests
    displayName: Post-Deployment Tests
    dependsOn:
      - Deploy
    condition: succeeded()
    jobs:
      - job: HealthCheck
        displayName: Health Check
        pool:
          name: Default
        steps:
          - task: AzureCLI@2
            displayName: Get App Service URL
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                APP_URL=$(az webapp show --name $(appServiceName) --resource-group $(resourceGroupName) --query "defaultHostName" --output tsv)
                echo "##vso[task.setvariable variable=appUrl]https://$APP_URL"
          - task: CmdLine@2
            displayName: Run health checks
            inputs:
              script: |
                echo "Testing application health at: $(appUrl)"
                # Wait for application to be ready
                sleep 30
                # Health check for /api/health
                response=$(curl -s -o /dev/null -w "%{http_code}" $(appUrl)/api/health)
                if [ $response -eq 200 ]; then
                  echo "✅ /api/health check passed"
                else
                  echo "❌ /api/health check failed with status: $response"
                  exit 1
                fi
                # Health check for root /
                response=$(curl -s -o /dev/null -w "%{http_code}" $(appUrl))
                if [ $response -eq 200 ]; then
                  echo "✅ Root endpoint is responding"
                else
                  echo "❌ Root endpoint not responding with status: $response"
                  exit 1
                fi
          - task: PublishTestResults@2
            displayName: Publish health check results
            condition: always()
            inputs:
              testResultsFormat: JUnit
              testResultsFiles: '**/health-check-results.xml'
              failTaskOnFailedTests: true
