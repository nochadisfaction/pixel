# Azure DevOps Pipeline for Pixelated Empathy
#
trigger:
  branches:
    include:
      - master
      - develop
  paths:
    include:
      - src/**
      - deploy/azure/**
      - Dockerfile.azure
      - azure-pipelines.yml
      - .azure-pipelines/**
      - package.json
      - pnpm-lock.yaml

pr:
  branches:
    include:
      - master
      - develop

variables:
  # Build Configuration
  buildConfiguration: Release
  nodeVersion: 22.x

  # Azure Configuration - Clean service connection reference
  azureSubscription: 'pixelated-service-connection'
  resourceGroupName: pixelated-rg
  appServiceName: pixelated-app
  containerRegistry: pixelatedcr.azurecr.io
  containerRegistryServiceConnection: 'Azure Container Registry'
  imageName: pixelated-web

  # Azure Resource Configuration
  azureSubscriptionId: $(AZURE_SUBSCRIPTION_ID)
  azureStorageContainerName: $(AZURE_STORAGE_CONTAINER_NAME)
  publicSiteUrl: $(PUBLIC_SITE_URL)

  # Build specific variables
  buildId: $(Build.BuildId)
  buildNumber: $(Build.BuildNumber)

  # Environment Variables
  ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/master') }}:
    environment: production
    deploymentSlot: production
    azureLocation: eastus
  ${{ else }}:
    environment: staging
    deploymentSlot: staging
    azureLocation: eastus

stages:
  # Build Stage
  - stage: Build
    displayName: Build Application
    jobs:
      - job: BuildJob
        displayName: Build and Test
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - task: NodeTool@0
            displayName: Install Node.js
            inputs:
              versionSpec: $(nodeVersion)

          - task: Cache@2
            displayName: Cache pnpm dependencies
            inputs:
              key: pnpm | "$(Agent.OS)" | pnpm-lock.yaml
              restoreKeys: |
                pnpm | "$(Agent.OS)"
              path: $(Pipeline.Workspace)/.pnpm-store

          - script: |
              npm install -g pnpm
              pnpm config set store-dir $(Pipeline.Workspace)/.pnpm-store
              pnpm install --no-frozen-lockfile
            displayName: Install dependencies

          - script: |
              pnpm run lint:ci
            displayName: Run linting
            continueOnError: true
            condition: succeededOrFailed()

          - script: |
              pnpm run type-check || echo "Type checking completed with warnings/errors but continuing build"
            displayName: Run type checking
            continueOnError: true
            condition: succeededOrFailed()

          - script: |
              export NODE_ENV=production
              export ASTRO_CONFIG_FILE=astro.config.azure.mjs
              pnpm build
            displayName: Build application
            env:
              NODE_ENV: production
              ASTRO_CONFIG_FILE: astro.config.azure.mjs

          - task: ArchiveFiles@2
            displayName: Archive build artifacts
            inputs:
              rootFolderOrFile: dist
              includeRootFolder: false
              archiveType: zip
              archiveFile: $(Build.ArtifactStagingDirectory)/app-$(Build.BuildId).zip

          - task: PublishBuildArtifacts@1
            displayName: Publish build artifacts
            inputs:
              pathToPublish: $(Build.ArtifactStagingDirectory)
              artifactName: drop

  # Docker Build Stage
  - stage: DockerBuild
    displayName: Build Docker Image
    dependsOn: Build
    condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/master'), eq(variables['Build.SourceBranch'], 'refs/heads/develop')))
    jobs:
      - job: DockerBuildJob
        displayName: Build and Push Docker Image
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - task: Docker@2
            displayName: Login to Azure Container Registry
            inputs:
              command: login
              containerRegistry: $(containerRegistryServiceConnection)

          - task: Docker@2
            displayName: Build Docker image
            inputs:
              command: build
              repository: $(imageName)
              dockerfile: Dockerfile.azure
              tags: |
                $(buildId)
                latest
              arguments: '--build-arg NODE_ENV=production'

          - task: Docker@2
            displayName: Push Docker image
            inputs:
              command: push
              containerRegistry: $(containerRegistryServiceConnection)
              repository: $(imageName)
              tags: |
                $(buildId)
                latest

  # Infrastructure Deployment Stage
  - stage: Infrastructure
    displayName: Deploy Infrastructure
    dependsOn: []
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
    jobs:
      - deployment: InfrastructureDeployment
        displayName: Deploy Azure Infrastructure
        environment: 'azure-infrastructure'
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  displayName: Checkout source code

                - task: AzureCLI@2
                  displayName: Deploy Bicep template
                  inputs:
                    azureSubscription: $(azureSubscription)
                    scriptType: bash
                    scriptLocation: inlineScript
                    addSpnToEnvironment: true
                    failOnStandardError: false
                    workingDirectory: $(System.DefaultWorkingDirectory)
                    inlineScript: |
                      set -euo pipefail

                      echo "Deploying infrastructure..."
                      echo "Resource Group: $(resourceGroupName)"
                      echo "Environment: $(environment)"

                      # Check if resource group exists, create if not
                      if ! az group show --name $(resourceGroupName) >/dev/null 2>&1; then
                        echo "Creating resource group $(resourceGroupName)..."
                        az group create \
                          --name $(resourceGroupName) \
                          --location $(azureLocation) \
                          --output none
                      fi

                      # Deploy infrastructure using Bicep
                      az deployment group create \
                        --resource-group $(resourceGroupName) \
                        --template-file deploy/azure/main.bicep \
                        --parameters \
                          appName=pixelated \
                          environment=$(environment) \
                          location=$(azureLocation) \
                          enableAzureOpenAI=false \
                          enableStorage=true \
                          enableMonitoring=true \
                        --output table

  # Application Deployment Stage
  - stage: Deploy
    displayName: Deploy Application
    dependsOn:
      - Build
      - DockerBuild
    condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/master'), eq(variables['Build.SourceBranch'], 'refs/heads/develop')))
    jobs:
      - deployment: AppServiceDeployment
        displayName: Deploy to Azure App Service
        environment: azure-$(environment)
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: AzureWebAppContainer@1
                  displayName: Deploy to Azure Web App (Container)
                  inputs:
                    azureSubscription: $(azureSubscription)
                    resourceGroupName: $(resourceGroupName)
                    appName: $(appServiceName)
                    slotName: $(deploymentSlot)
                    imageName: $(containerRegistry)/$(imageName):$(buildId)

                - task: AzureAppServiceSettings@1
                  displayName: Configure App Service settings
                  inputs:
                    azureSubscription: $(azureSubscription)
                    appName: $(appServiceName)
                    resourceGroupName: $(resourceGroupName)
                    slotName: $(deploymentSlot)
                    appSettings: |
                      [
                        {
                          "name": "NODE_ENV",
                          "value": "$(environment)"
                        },
                        {
                          "name": "WEBSITES_PORT",
                          "value": "8080"
                        },
                        {
                          "name": "WEBSITES_ENABLE_APP_SERVICE_STORAGE",
                          "value": "false"
                        },
                        {
                          "name": "ASTRO_CONFIG_FILE",
                          "value": "astro.config.azure.mjs"
                        },
                        {
                          "name": "SCM_DO_BUILD_DURING_DEPLOYMENT",
                          "value": "false"
                        }
                      ]

  # Post-Deployment Testing
  - stage: PostDeploymentTests
    displayName: Post-Deployment Tests
    dependsOn: Deploy
    condition: succeeded()
    jobs:
      - job: HealthCheck
        displayName: Health Check
        pool:
          vmImage: 'ubuntu-latest'

        steps:
          - task: AzureCLI@2
            displayName: Get App Service URL and Run Health Checks
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: bash
              scriptLocation: inlineScript
              addSpnToEnvironment: true
              failOnStandardError: false
              inlineScript: |
                set -e

                echo "Getting App Service URL for $(appServiceName)..."
                APP_URL=$(az webapp show --name $(appServiceName) --resource-group $(resourceGroupName) --query "defaultHostName" --output tsv --only-show-errors)

                if [ -z "$APP_URL" ]; then
                  echo "Failed to get App Service URL"
                  exit 1
                fi

                echo "App Service URL: https://$APP_URL"

                # Wait for application to be ready
                sleep 30

                # Health check for /api/health
                response=$(curl -s -o /dev/null -w "%{http_code}" https://$APP_URL/api/health)
                if [ $response -eq 200 ]; then
                  echo "✅ /api/health check passed"
                else
                  echo "❌ /api/health check failed with status: $response"
                  exit 1
                fi

                # Health check for root /
                response=$(curl -s -o /dev/null -w "%{http_code}" https://$APP_URL)
                if [ $response -eq 200 ]; then
                  echo "✅ Root endpoint is responding"
                else
                  echo "❌ Root endpoint not responding with status: $response"
                  exit 1
                fi